/**
 * PineScript Code Generator
 * Converts visual strategy graph to PineScript v5 code
 * Also supports form-based condition model
 */

import { 
  Indicators, 
  PriceSources, 
  ComparisonOperators,
  getIndicator,
  getPriceSource,
  isCrossOperator,
  isMultiOutput,
  getIndicatorOutputs,
  getDefaultOutputIndex,
  getMathFunction,
  migrateExpression,
} from './condition-types.js'

// Legacy block-based generator functions are preserved below for reference
// but are no longer used. The new form-based generator is at the bottom of this file.

// Stub for legacy block-based code (deprecated)
function getBlockDefinition() {
  console.warn('getBlockDefinition is deprecated - use form-based generator instead')
  return null
}

/**
 * Generate PineScript code from nodes and edges
 * @param {Object} graph - { nodes, edges }
 * @param {Object} options - { strategyName, initialCapital, etc }
 * @returns {string} Generated PineScript code
 */
export function generatePineScript(graph, options = {}) {
  const { nodes, edges } = graph
  const {
    strategyName = 'My Strategy',
    initialCapital = 10000,
    defaultQty = 100,
    pyramiding = 0,
    currency = 'USD',
  } = options

  if (!nodes || nodes.length === 0) {
    return ''
  }

  // Build dependency graph
  const nodeMap = new Map(nodes.map(n => [n.id, n]))
  const dependencies = buildDependencies(nodes, edges)
  
  // Topological sort for correct ordering
  const sortedNodes = topologicalSort(nodes, dependencies)
  
  // Separate by type
  const variableNodes = sortedNodes.filter(n => getBlockDefinition(n.data?.blockType)?.isVariable)
  const calculationNodes = sortedNodes.filter(n => {
    const def = getBlockDefinition(n.data?.blockType)
    return !def?.isVariable && !def?.isSignal && !def?.isBuiltinVar
  })
  const signalNodes = sortedNodes.filter(n => getBlockDefinition(n.data?.blockType)?.isSignal)
  
  // Generate code sections
  const lines = []
  
  // Header
  lines.push('//@version=6')
  lines.push(`strategy("${strategyName}", overlay=true, initial_capital=${initialCapital}, default_qty_type=strategy.fixed, default_qty_value=${defaultQty}, pyramiding=${pyramiding}, currency="${currency}")`)
  lines.push('')
  lines.push('// === Generated by Backtest Strategy Builder ===')
  lines.push('')
  
  // Variable definitions
  const varDefs = generateVariableDefinitions(variableNodes, nodeMap)
  if (varDefs.length > 0) {
    lines.push('// === Variables ===')
    lines.push(...varDefs)
    lines.push('')
  }
  
  // Calculations (indicators, conditions, etc)
  const calculations = generateCalculations(calculationNodes, edges, nodeMap)
  if (calculations.length > 0) {
    lines.push('// === Calculations ===')
    lines.push(...calculations)
    lines.push('')
  }
  
  // Variable updates (after calculations, before signals)
  const varUpdates = generateVariableUpdates(variableNodes, edges, nodeMap)
  if (varUpdates.length > 0) {
    lines.push('// === Variable Updates ===')
    lines.push(...varUpdates)
    lines.push('')
  }
  
  // Trading signals
  const signals = generateSignals(signalNodes, edges, nodeMap)
  if (signals.length > 0) {
    lines.push('// === Trading Signals ===')
    lines.push(...signals)
  }
  
  return lines.join('\n')
}

/**
 * Build dependency map from edges
 */
function buildDependencies(nodes, edges) {
  const deps = new Map()
  
  nodes.forEach(n => deps.set(n.id, []))
  
  edges.forEach(edge => {
    const targetDeps = deps.get(edge.target) || []
    targetDeps.push(edge.source)
    deps.set(edge.target, targetDeps)
  })
  
  return deps
}

/**
 * Topological sort using Kahn's algorithm
 */
function topologicalSort(nodes, dependencies) {
  const inDegree = new Map()
  const nodeMap = new Map(nodes.map(n => [n.id, n]))
  
  // Initialize in-degrees
  nodes.forEach(n => inDegree.set(n.id, 0))
  
  // Count incoming edges
  dependencies.forEach((deps, nodeId) => {
    inDegree.set(nodeId, deps.length)
  })
  
  // Start with nodes that have no dependencies
  const queue = []
  inDegree.forEach((degree, nodeId) => {
    if (degree === 0) queue.push(nodeId)
  })
  
  const sorted = []
  while (queue.length > 0) {
    const nodeId = queue.shift()
    const node = nodeMap.get(nodeId)
    if (node) sorted.push(node)
    
    // Reduce in-degree for dependent nodes
    dependencies.forEach((deps, depNodeId) => {
      if (deps.includes(nodeId)) {
        const newDegree = inDegree.get(depNodeId) - 1
        inDegree.set(depNodeId, newDegree)
        if (newDegree === 0) queue.push(depNodeId)
      }
    })
  }
  
  return sorted
}

/**
 * Generate variable name from node
 */
function getVarName(node) {
  const blockType = node.data?.blockType || 'unknown'
  const shortId = node.id.split('_').pop()
  return `${blockType}_${shortId}`
}

/**
 * Get input expression for a node
 */
function getInputExpression(node, inputId, edges, nodeMap) {
  // Find edge connecting to this input
  const edge = edges.find(e => e.target === node.id && e.targetHandle === inputId)
  
  if (!edge) {
    // Use default value from block definition
    const blockDef = getBlockDefinition(node.data?.blockType)
    const input = blockDef?.inputs?.find(i => i.id === inputId)
    return input?.default || 'close'
  }
  
  // Get source node
  const sourceNode = nodeMap.get(edge.source)
  if (!sourceNode) return 'close'
  
  const sourceBlockDef = getBlockDefinition(sourceNode.data?.blockType)
  
  // If source is a simple price data or has pinescript function, use directly
  if (sourceBlockDef?.pinescript && !sourceBlockDef.multiOutput) {
    const params = sourceNode.data?.params || {}
    const inputs = resolveInputs(sourceNode, edges, nodeMap)
    return sourceBlockDef.pinescript(params, inputs)
  }
  
  // Otherwise reference the variable
  return getVarName(sourceNode) + (edge.sourceHandle && edge.sourceHandle !== 'value' ? `_${edge.sourceHandle}` : '')
}

/**
 * Resolve all inputs for a node
 */
function resolveInputs(node, edges, nodeMap) {
  const blockDef = getBlockDefinition(node.data?.blockType)
  const inputs = {}
  
  blockDef?.inputs?.forEach(input => {
    inputs[input.id] = getInputExpression(node, input.id, edges, nodeMap)
  })
  
  return inputs
}

/**
 * Generate variable definitions
 */
function generateVariableDefinitions(variableNodes, nodeMap) {
  const lines = []
  
  variableNodes
    .filter(n => n.data?.blockType === 'defineVariable')
    .forEach(node => {
      const params = node.data?.params || {}
      const name = params.name || 'myVar'
      const varType = params.varType || 'float'
      const initial = params.initialValue || 'na'
      
      lines.push(`var ${varType} ${name} = ${initial}`)
    })
  
  return lines
}

/**
 * Generate calculations (indicators, conditions, math)
 */
function generateCalculations(nodes, edges, nodeMap) {
  const lines = []
  const generated = new Set()
  
  nodes.forEach(node => {
    const blockDef = getBlockDefinition(node.data?.blockType)
    if (!blockDef || blockDef.isBuiltinVar) return
    
    const varName = getVarName(node)
    if (generated.has(varName)) return
    
    const params = node.data?.params || {}
    const inputs = resolveInputs(node, edges, nodeMap)
    
    if (blockDef.pinescript) {
      if (blockDef.multiOutput) {
        // Multi-output like MACD
        const expr = blockDef.pinescript(params, inputs)
        lines.push(`[${varName}_macd, ${varName}_signal, ${varName}_hist] = ${expr}`)
      } else {
        const expr = blockDef.pinescript(params, inputs)
        lines.push(`${varName} = ${expr}`)
      }
      generated.add(varName)
    }
  })
  
  return lines
}

/**
 * Generate variable updates
 */
function generateVariableUpdates(variableNodes, edges, nodeMap) {
  const lines = []
  
  variableNodes
    .filter(n => n.data?.blockType === 'updateVariable')
    .forEach(node => {
      const params = node.data?.params || {}
      const varName = params.variableName
      if (!varName) return
      
      const valueExpr = getInputExpression(node, 'value', edges, nodeMap)
      const triggerEdge = edges.find(e => e.target === node.id && e.targetHandle === 'trigger')
      
      if (triggerEdge) {
        const triggerExpr = getInputExpression(node, 'trigger', edges, nodeMap)
        lines.push(`if ${triggerExpr}`)
        lines.push(`    ${varName} := ${valueExpr}`)
      } else {
        lines.push(`${varName} := ${valueExpr}`)
      }
    })
  
  return lines
}

/**
 * Generate trading signals (entry/exit)
 */
function generateSignals(signalNodes, edges, nodeMap) {
  const lines = []
  
  signalNodes.forEach(node => {
    const blockDef = getBlockDefinition(node.data?.blockType)
    if (!blockDef?.isSignal) return
    
    const params = node.data?.params || {}
    const label = params.label || (blockDef.direction === 'long' ? 'Long' : 'Short')
    const conditionExpr = getInputExpression(node, 'condition', edges, nodeMap)
    
    const { signalType, direction, alertMessage } = blockDef
    
    lines.push(`// ${blockDef.label}`)
    lines.push(`if ${conditionExpr}`)
    
    if (signalType === 'entry') {
      const stratDirection = direction === 'long' ? 'strategy.long' : 'strategy.short'
      lines.push(`    strategy.entry("${label}", ${stratDirection}, alert_message="${alertMessage}")`)
    } else {
      // Exit - use strategy.close
      lines.push(`    strategy.close("${label}", alert_message="${alertMessage}")`)
    }
    lines.push('')
  })
  
  return lines
}

/**
 * Validate the strategy graph
 * @returns {Array} Array of warning/error messages
 */
export function validateGraph(graph) {
  const { nodes, edges } = graph
  const warnings = []
  
  if (!nodes || nodes.length === 0) {
    warnings.push({ type: 'info', message: 'Canvas is empty, please add blocks' })
    return warnings
  }
  
  // Check for signal nodes
  const signalNodes = nodes.filter(n => getBlockDefinition(n.data?.blockType)?.isSignal)
  if (signalNodes.length === 0) {
    warnings.push({ type: 'warning', message: 'No entry/exit signal blocks found, strategy will not generate any trades' })
  }
  
  // Check for unconnected signal conditions
  signalNodes.forEach(node => {
    const conditionEdge = edges.find(e => e.target === node.id && e.targetHandle === 'condition')
    if (!conditionEdge) {
      const blockDef = getBlockDefinition(node.data?.blockType)
      warnings.push({ 
        type: 'error', 
        message: `${blockDef?.label || 'Signal block'} has no connected condition` 
      })
    }
  })
  
  // Check for orphan nodes (no connections)
  nodes.forEach(node => {
    const blockDef = getBlockDefinition(node.data?.blockType)
    if (!blockDef) return
    
    const hasInputConnection = edges.some(e => e.target === node.id)
    const hasOutputConnection = edges.some(e => e.source === node.id)
    
    // Only warn if node has outputs but nothing is connected
    if (blockDef.outputs?.length > 0 && !hasOutputConnection && !blockDef.isSignal) {
      warnings.push({ 
        type: 'info', 
        message: `${blockDef.label} output is not connected to any block` 
      })
    }
  })
  
  // Check variable references
  const definedVars = nodes
    .filter(n => n.data?.blockType === 'defineVariable')
    .map(n => n.data?.params?.name)
    .filter(Boolean)
  
  nodes
    .filter(n => ['readVariable', 'updateVariable'].includes(n.data?.blockType))
    .forEach(node => {
      const varName = node.data?.params?.variableName
      if (varName && !definedVars.includes(varName)) {
        warnings.push({
          type: 'error',
          message: `Variable "${varName}" is not defined`
        })
      }
    })
  
  return warnings
}

// ============================================================================
// Form-Based Condition Generator (New Model)
// ============================================================================

/**
 * Generate PineScript code from form-based condition model
 * @param {Object} strategy - Strategy object with signals, variables, inputs, settings
 * @returns {string} Generated PineScript code
 */
export function generatePineScriptFromConditions(strategy) {
  const {
    name = 'My Strategy',
    settings = {},
    signals = {},
    variables = [],
    inputs = [],
  } = strategy

  const {
    initialCapital = 10000,
    currency = 'USD',
    orderSize = 100,
    orderType = 'percent',
    pyramiding = 0,
    commission = 0,
    commissionType = 'percent',
    slippage = 0,
    calcOnEveryTick = false,
    processOrdersOnClose = false,
  } = settings

  const lines = []
  
  // Header
  lines.push('//@version=6')
  
  // Build strategy() call with all settings
  const qtyType = orderType === 'percent' ? 'strategy.percent_of_equity' : 'strategy.fixed'
  let strategyArgs = [
    `"${name}"`,
    'overlay=true',
    `initial_capital=${initialCapital}`,
    `default_qty_type=${qtyType}`,
    `default_qty_value=${orderSize}`,
    `currency="${currency}"`,
  ]
  if (pyramiding > 0) {
    strategyArgs.push(`pyramiding=${pyramiding}`)
  }
  if (commission > 0) {
    const commType = commissionType === 'fixed' ? 'strategy.commission.cash_per_contract' : 'strategy.commission.percent'
    strategyArgs.push(`commission_type=${commType}`)
    strategyArgs.push(`commission_value=${commission}`)
  }
  if (slippage > 0) {
    strategyArgs.push(`slippage=${slippage}`)
  }
  if (calcOnEveryTick) {
    strategyArgs.push('calc_on_every_tick=true')
  }
  if (processOrdersOnClose) {
    strategyArgs.push('process_orders_on_close=true')
  }
  
  lines.push(`strategy(${strategyArgs.join(', ')})`)
  lines.push('')
  lines.push('// === Generated by Backtest Strategy Builder ===')
  lines.push('')
  
  // Collect all inputs from conditions
  const collectedInputs = collectInputsFromStrategy(strategy)
  const allInputs = [...inputs, ...collectedInputs]
  
  // Collect exit settings from entry signals
  const longExitSettings = signals.longEntry?.exitSettings || {}
  const shortExitSettings = signals.shortEntry?.exitSettings || {}
  const hasLongTPSL = longExitSettings.takeProfitEnabled || longExitSettings.stopLossEnabled
  const hasShortTPSL = shortExitSettings.takeProfitEnabled || shortExitSettings.stopLossEnabled
  const hasAnyExitSettings = hasLongTPSL || hasShortTPSL

  // Generate input declarations
  if (allInputs.length > 0 || hasAnyExitSettings) {
    lines.push('// === Strategy Parameters ===')
    allInputs.forEach(input => {
      lines.push(generateInputDeclaration(input))
    })
    // TP/SL input declarations per direction
    if (hasAnyExitSettings) {
      const exitInputLines = generateExitInputDeclarations(longExitSettings, shortExitSettings)
      exitInputLines.forEach(l => lines.push(l))
    }
    lines.push('')
  }

  // =====================================================================
  // Indicator call deduplication
  // Scan ALL indicator usages (from variables AND conditions) to ensure
  // each unique call is computed only once, regardless of single/multi output.
  // =====================================================================
  
  // Registry for multi-output indicators (need tuple destructuring)
  const multiOutputRegistry = new Map() // callKey -> { indicator, indicatorId, params, outputs, slots: Map<outputIndex, varName> }
  
  // Registry for single-output indicators used 2+ times (need simple variable)
  const singleOutputRegistry = new Map() // callKey -> { indicatorId, params, varName, count }
  
  let _autoCounter = 0
  
  /**
   * Register any indicator usage. Returns the variable name if hoisted.
   */
  function registerIndicatorUsage(indicatorId, params, outputIndex, preferredName) {
    const indicator = getIndicator(indicatorId)
    if (!indicator) return null
    const resolvedParams = resolveIndicatorParams(params, variables)
    const callKey = `${indicatorId}|${JSON.stringify(resolvedParams)}|${outputIndex ?? 0}`
    
    if (isMultiOutput(indicatorId)) {
      // Multi-output: use tuple destructuring registry
      const moKey = `${indicatorId}|${JSON.stringify(resolvedParams)}`
      if (!multiOutputRegistry.has(moKey)) {
        multiOutputRegistry.set(moKey, {
          indicator, indicatorId, params: resolvedParams,
          outputs: getIndicatorOutputs(indicatorId),
          slots: new Map(),
        })
      }
      const entry = multiOutputRegistry.get(moKey)
      const idx = outputIndex ?? 0
      if (!entry.slots.has(idx)) {
        entry.slots.set(idx, preferredName || `_${indicatorId}_${idx}`)
      }
      return entry.slots.get(idx)
    } else {
      // Single-output: count usages
      if (!singleOutputRegistry.has(callKey)) {
        singleOutputRegistry.set(callKey, {
          indicatorId, params: resolvedParams, outputIndex,
          varName: preferredName || null,
          count: 0,
        })
      }
      const entry = singleOutputRegistry.get(callKey)
      entry.count++
      if (preferredName && !entry.varName) {
        entry.varName = preferredName
      }
      return entry.varName
    }
  }
  
  // Pass 1: register from user-defined variables
  variables.forEach(variable => {
    if ((variable.type || 'indicator') === 'indicator') {
      registerIndicatorUsage(variable.indicator, variable.params, variable.outputIndex ?? 0, variable.name)
    }
  })
  
  // Pass 2: scan all condition operands
  function scanOperand(operand) {
    if (!operand || operand.type !== 'indicator') return
    registerIndicatorUsage(operand.indicator, operand.params, operand.outputIndex ?? 0, null)
  }
  
  Object.values(signals).forEach(signal => {
    if (!signal?.enabled) return
    signal.groups?.forEach(group => {
      group.conditions?.forEach(cond => {
        scanOperand(cond.left)
        scanOperand(cond.right)
      })
    })
  })
  
  // Assign auto-generated names for multi-output slots without user names
  multiOutputRegistry.forEach((entry) => {
    entry.slots.forEach((name, idx) => {
      if (name.startsWith('_')) {
        _autoCounter++
        const outputDef = entry.outputs[idx]
        entry.slots.set(idx, `_${entry.indicatorId}_${outputDef?.id || idx}_${_autoCounter}`)
      }
    })
  })
  
  // Assign auto-generated names for single-output indicators used 2+ times
  singleOutputRegistry.forEach((entry, callKey) => {
    if (entry.count >= 2 && !entry.varName) {
      _autoCounter++
      entry.varName = `_${entry.indicatorId}_${_autoCounter}`
    }
  })
  
  // Collect all hoisted variable names
  const hoistedVarNames = new Set()
  multiOutputRegistry.forEach(entry => {
    entry.slots.forEach(name => hoistedVarNames.add(name))
  })
  singleOutputRegistry.forEach(entry => {
    if (entry.count >= 2 && entry.varName) hoistedVarNames.add(entry.varName)
  })
  
  // Emit indicator calculation section
  const hasMultiOutput = multiOutputRegistry.size > 0
  const hasSingleDedup = [...singleOutputRegistry.values()].some(e => e.count >= 2 && e.varName)
  const hasHoisted = hasMultiOutput || hasSingleDedup
  
  if (hasHoisted || variables.length > 0) {
    lines.push('// === Indicator Calculations ===')
  }
  
  // Emit multi-output destructuring
  multiOutputRegistry.forEach((entry) => {
    const { indicator, params, outputs, slots } = entry
    const lhsParts = outputs.map((_, i) => slots.has(i) ? slots.get(i) : '_')
    const callExpr = indicator.pineCall
      ? indicator.pineCall(params)
      : indicator.pinescript(params, 0).replace(/\[\d+\]$/, '')
    lines.push(`[${lhsParts.join(', ')}] = ${callExpr}`)
  })
  
  // Emit single-output deduplicated variables
  singleOutputRegistry.forEach((entry) => {
    if (entry.count < 2 || !entry.varName) return
    if (hoistedVarNames.has(entry.varName) && variables.some(v => v.name === entry.varName)) return // user variable handles it
    const indicator = getIndicator(entry.indicatorId)
    if (!indicator) return
    const expr = isMultiOutput(entry.indicatorId)
      ? indicator.pinescript(entry.params, entry.outputIndex ?? 0)
      : indicator.pinescript(entry.params)
    // Only emit if not already covered by a user-defined variable
    if (!variables.some(v => v.name === entry.varName)) {
      lines.push(`${entry.varName} = ${expr}`)
    }
  })
  
  // Build lookup: given any indicator operand, find its hoisted var name
  function lookupHoistedVar(indicatorId, params, outputIndex) {
    const resolvedParams = resolveIndicatorParams(params, variables)
    
    // Check multi-output registry first
    if (isMultiOutput(indicatorId)) {
      const moKey = `${indicatorId}|${JSON.stringify(resolvedParams)}`
      const entry = multiOutputRegistry.get(moKey)
      if (entry) return entry.slots.get(outputIndex ?? 0) || null
    }
    
    // Check single-output registry
    const callKey = `${indicatorId}|${JSON.stringify(resolvedParams)}|${outputIndex ?? 0}`
    const entry = singleOutputRegistry.get(callKey)
    if (entry && entry.count >= 2 && entry.varName) return entry.varName
    
    return null
  }
  
  // Generate custom variables (non-hoisted ones)
  if (variables.length > 0) {
    variables.forEach(variable => {
      if (hoistedVarNames.has(variable.name)) return // Already emitted via hoisting
      const expr = generateVariableExpression(variable, variables)
      lines.push(`${variable.name} = ${expr}`)
    })
  }
  
  if (hasHoisted || variables.length > 0) {
    lines.push('')
  }
  
  // Generate signal conditions
  lines.push('// === Signal Conditions ===')
  
  const signalConfigs = [
    { key: 'longEntry', label: 'Long Entry', varName: 'longEntryCondition' },
    { key: 'longExit', label: 'Long Exit', varName: 'longExitCondition' },
    { key: 'shortEntry', label: 'Short Entry', varName: 'shortEntryCondition' },
    { key: 'shortExit', label: 'Short Exit', varName: 'shortExitCondition' },
  ]
  
  signalConfigs.forEach(({ key, label, varName }) => {
    const signal = signals[key]
    if (signal?.enabled && signal.groups.length > 0) {
      const conditionExpr = generateSignalCondition(signal, variables, lookupHoistedVar)
      lines.push(`${varName} = ${conditionExpr}`)
    } else {
      lines.push(`${varName} = false`)
    }
  })
  lines.push('')
  
  // Generate strategy execution
  lines.push('// === Strategy Execution ===')

  if (signals.longEntry?.enabled && signals.longEntry.groups.length > 0) {
    lines.push('if longEntryCondition')
    lines.push('    strategy.entry("Long", strategy.long, alert_message="long_entry")')
    if (hasLongTPSL) {
      lines.push(`    strategy.exit(${buildExitArgs('Long', 'long', longExitSettings).join(', ')})`)
    }
    lines.push('')
  }

  if (signals.longExit?.enabled && signals.longExit.groups.length > 0) {
    lines.push('if longExitCondition')
    lines.push('    strategy.close("Long", alert_message="long_exit")')
    lines.push('')
  }

  if (signals.shortEntry?.enabled && signals.shortEntry.groups.length > 0) {
    lines.push('if shortEntryCondition')
    lines.push('    strategy.entry("Short", strategy.short, alert_message="short_entry")')
    if (hasShortTPSL) {
      lines.push(`    strategy.exit(${buildExitArgs('Short', 'short', shortExitSettings).join(', ')})`)
    }
    lines.push('')
  }

  if (signals.shortExit?.enabled && signals.shortExit.groups.length > 0) {
    lines.push('if shortExitCondition')
    lines.push('    strategy.close("Short", alert_message="short_exit")')
    lines.push('')
  }
  
  return lines.join('\n')
}

/**
 * Generate exit input declarations for TP/SL per direction.
 * Deduplicates when both long and short use the same mode & value.
 */
function generateExitInputDeclarations(longES, shortES) {
  const lines = []
  const declared = new Set()

  function declareTP(prefix, label, es) {
    const varName = `${prefix}TakeProfit`
    if (declared.has(varName)) return
    declared.add(varName)
    if (es.takeProfitMode === 'percent') {
      lines.push(`${varName} = input.float(${es.takeProfitValue}, "${label} Take Profit (%)", minval=0.01)`)
    } else {
      lines.push(`${varName} = input.int(${es.takeProfitValue}, "${label} Take Profit (pts)", minval=1)`)
    }
  }

  function declareSL(prefix, label, es) {
    const varName = `${prefix}StopLoss`
    if (declared.has(varName)) return
    declared.add(varName)
    if (es.stopLossMode === 'percent') {
      lines.push(`${varName} = input.float(${es.stopLossValue}, "${label} Stop Loss (%)", minval=0.01)`)
    } else {
      lines.push(`${varName} = input.int(${es.stopLossValue}, "${label} Stop Loss (pts)", minval=1)`)
    }
  }

  if (longES.takeProfitEnabled) declareTP('long', 'Long', longES)
  if (longES.stopLossEnabled) declareSL('long', 'Long', longES)
  if (shortES.takeProfitEnabled) declareTP('short', 'Short', shortES)
  if (shortES.stopLossEnabled) declareSL('short', 'Short', shortES)

  return lines
}

/**
 * Build strategy.exit() argument list for a direction.
 * @param {string} posLabel - "Long" or "Short"
 * @param {string} direction - "long" or "short"
 * @param {Object} es - exitSettings from signal
 * @returns {string[]} argument list
 */
function buildExitArgs(posLabel, direction, es) {
  const args = [`"${posLabel} TP/SL"`, `"${posLabel}"`]
  const isLong = direction === 'long'
  const prefix = isLong ? 'long' : 'short'

  if (es.takeProfitEnabled) {
    if (es.takeProfitMode === 'percent') {
      const expr = isLong
        ? `close * (1 + ${prefix}TakeProfit / 100)`
        : `close * (1 - ${prefix}TakeProfit / 100)`
      args.push(`limit=${expr}`)
    } else {
      const expr = isLong
        ? `close + ${prefix}TakeProfit`
        : `close - ${prefix}TakeProfit`
      args.push(`limit=${expr}`)
    }
  }

  if (es.stopLossEnabled) {
    if (es.stopLossMode === 'percent') {
      const expr = isLong
        ? `close * (1 - ${prefix}StopLoss / 100)`
        : `close * (1 + ${prefix}StopLoss / 100)`
      args.push(`stop=${expr}`)
    } else {
      const expr = isLong
        ? `close - ${prefix}StopLoss`
        : `close + ${prefix}StopLoss`
      args.push(`stop=${expr}`)
    }
  }

  const alertMsg = isLong ? 'long_exit' : 'short_exit'
  args.push(`alert_message="${alertMsg}"`)
  return args
}

/**
 * Generate input declaration PineScript
 */
function generateInputDeclaration(input) {
  // Use stored varName if available (from quick-create), otherwise generate
  const varName = input._varName || toCamelCase(input.name)
  
  if (input.type === 'int') {
    let code = `${varName} = input.int(${input.default}, "${input.name}"`
    if (input.min !== undefined && input.min !== null) code += `, minval=${input.min}`
    if (input.max !== undefined && input.max !== null) code += `, maxval=${input.max}`
    return code + ')'
  }
  
  if (input.type === 'float') {
    let code = `${varName} = input.float(${input.default}, "${input.name}"`
    if (input.min !== undefined && input.min !== null) code += `, minval=${input.min}`
    if (input.max !== undefined && input.max !== null) code += `, maxval=${input.max}`
    return code + ')'
  }
  
  if (input.type === 'bool') {
    return `${varName} = input.bool(${input.default}, "${input.name}")`
  }
  
  return `${varName} = input(${input.default}, "${input.name}")`
}

/**
 * Generate variable expression from variable definition
 */
function generateVariableExpression(variable, allVariables) {
  // Handle price-type variables
  const varType = variable.type || 'indicator'
  
  if (varType === 'price') {
    const source = getPriceSource(variable.source)
    return source?.pinescript || variable.source || 'close'
  }
  
  // Handle expression-type variables (derived variables) â€” recursive tree
  if (varType === 'expression') {
    const expr = migrateExpression(variable.expression)
    return generateExprTree(expr, allVariables)
  }
  
  // Handle indicator-type variables
  const indicator = getIndicator(variable.indicator)
  if (!indicator) return 'na'
  
  try {
    // Resolve any variable references in params
    const resolvedParams = resolveIndicatorParams(variable.params, allVariables)
    const outputIndex = variable.outputIndex ?? 0
    
    // For multi-output indicators, pass the output index
    if (isMultiOutput(variable.indicator)) {
      return indicator.pinescript(resolvedParams, outputIndex)
    }
    
    return indicator.pinescript(resolvedParams)
  } catch (e) {
    return 'na'
  }
}

/**
 * Recursively generate PineScript from an expression tree node.
 * Supports: price, variable, constant, input (leaves),
 *           binary (A op B), unary (-x), func (math.abs, math.max, etc.)
 */
function generateExprTree(node, allVariables) {
  if (!node) return 'na'

  switch (node.type) {
    case 'price': {
      const source = getPriceSource(node.source)
      return source?.pinescript || node.source || 'close'
    }
    case 'variable': {
      const refVar = allVariables.find(v => v.id === node.variableId)
      return refVar?.name || 'na'
    }
    case 'constant':
      return String(node.value ?? 0)
    case 'input':
      return node.inputName || 'na'
    case 'binary': {
      const left = generateExprTree(node.left, allVariables)
      const right = generateExprTree(node.right, allVariables)
      const op = node.operator || '+'
      return `(${left} ${op} ${right})`
    }
    case 'unary': {
      const operand = generateExprTree(node.operand, allVariables)
      if (node.func === 'negate') return `(-${operand})`
      return `${node.func}(${operand})`
    }
    case 'func': {
      const fn = getMathFunction(node.name)
      if (!fn) return 'na'
      const argStrs = (node.args || []).map(a => generateExprTree(a, allVariables))
      return fn.pinescript(argStrs)
    }
    default:
      return 'na'
  }
}

/**
 * Generate signal condition expression from groups (OR) and conditions (AND)
 * @param {Function} lookupHoistedVar - optional lookup for hoisted indicator vars
 */
function generateSignalCondition(signal, variables, lookupHoistedVar) {
  if (!signal.groups || signal.groups.length === 0) {
    return 'false'
  }
  
  const groupExprs = signal.groups
    .filter(g => g.conditions && g.conditions.length > 0)
    .map(group => {
      const condExprs = group.conditions.map(cond => generateConditionExpression(cond, variables, lookupHoistedVar))
      
      if (condExprs.length === 0) return null
      if (condExprs.length === 1) return condExprs[0]
      return `(${condExprs.join(' and ')})`
    })
    .filter(Boolean)
  
  if (groupExprs.length === 0) return 'false'
  if (groupExprs.length === 1) return groupExprs[0]
  return groupExprs.join(' or ')
}

/**
 * Generate a single condition expression
 */
function generateConditionExpression(condition, variables, lookupHoistedVar) {
  const leftExpr = generateOperandExpression(condition.left, variables, lookupHoistedVar)
  const rightExpr = generateOperandExpression(condition.right, variables, lookupHoistedVar)
  const opId = condition.operator
  
  // Handle crossover/crossunder/cross operators
  if (opId === 'crossover') {
    return `ta.crossover(${leftExpr}, ${rightExpr})`
  }
  if (opId === 'crossunder') {
    return `ta.crossunder(${leftExpr}, ${rightExpr})`
  }
  if (opId === 'cross') {
    return `ta.cross(${leftExpr}, ${rightExpr})`
  }
  
  // Standard comparison operators
  const opMap = {
    lt: '<',
    gt: '>',
    lte: '<=',
    gte: '>=',
    eq: '==',
    neq: '!=',
  }
  
  const op = opMap[opId] || '=='
  return `${leftExpr} ${op} ${rightExpr}`
}

/**
 * Resolve a param value - handles constants, variable references, and input references
 */
function resolveParamValue(paramValue, variables) {
  // If it's a variable reference object
  if (paramValue && typeof paramValue === 'object' && paramValue.type === 'variable') {
    const variable = variables.find(v => v.id === paramValue.variableId)
    return variable?.name || 'na'
  }
  // If it's a TradingView input reference
  if (paramValue && typeof paramValue === 'object' && paramValue.type === 'input') {
    return paramValue.inputName || 'na'
  }
  // Otherwise it's a direct value (number, string)
  return paramValue
}

/**
 * Preprocess indicator params to resolve variable references
 */
function resolveIndicatorParams(params, variables) {
  if (!params) return {}
  
  const resolved = {}
  for (const [key, value] of Object.entries(params)) {
    resolved[key] = resolveParamValue(value, variables)
  }
  return resolved
}

/**
 * Generate expression for an operand (left or right side of condition)
 * @param {Function} lookupHoistedVar - optional lookup for hoisted indicator vars
 */
function generateOperandExpression(operand, variables, lookupHoistedVar) {
  if (!operand) return 'na'
  
  switch (operand.type) {
    case 'indicator': {
      const indicator = getIndicator(operand.indicator)
      if (!indicator) return 'na'
      
      // Try to reference a hoisted variable (works for both single and multi-output)
      if (lookupHoistedVar) {
        const hoistedName = lookupHoistedVar(operand.indicator, operand.params, operand.outputIndex ?? 0)
        if (hoistedName) return hoistedName
      }
      
      try {
        // Resolve any variable references in params before generating PineScript
        const resolvedParams = resolveIndicatorParams(operand.params, variables)
        const outputIndex = operand.outputIndex ?? 0
        
        // For multi-output indicators, pass the output index
        if (isMultiOutput(operand.indicator)) {
          return indicator.pinescript(resolvedParams, outputIndex)
        }
        
        return indicator.pinescript(resolvedParams)
      } catch (e) {
        return 'na'
      }
    }
    
    case 'price': {
      const source = getPriceSource(operand.source)
      return source?.pinescript || 'close'
    }
    
    case 'variable': {
      const variable = variables.find(v => v.id === operand.variableId)
      return variable?.name || 'na'
    }
    
    case 'constant': {
      return operand.value?.toString() || '0'
    }
    
    case 'input': {
      return operand.inputName || 'na'
    }
    
    default:
      return 'na'
  }
}

/**
 * Collect inputs that are referenced in conditions
 * (for auto-generating input declarations)
 */
function collectInputsFromStrategy(strategy) {
  // TODO: Implement input collection from conditions
  // This would scan through all conditions and find parameter references
  return []
}

/**
 * Convert string to camelCase for variable names
 */
/**
 * Convert a display name to a valid PineScript variable name.
 * PineScript identifiers: [a-zA-Z_][a-zA-Z0-9_]*
 */
function toCamelCase(str) {
  const ascii = str.replace(/[^a-zA-Z0-9_\s]/g, '').trim()
  
  if (ascii) {
    const result = ascii
      .split(/[\s_]+/)
      .filter(Boolean)
      .map((word, index) => {
        if (index === 0) return word.toLowerCase()
        return word.charAt(0).toUpperCase() + word.slice(1).toLowerCase()
      })
      .join('')
    
    if (/^[a-zA-Z_]/.test(result)) return result
    return '_' + result
  }
  
  return 'param_' + Date.now().toString(36).slice(-4)
}

/**
 * Validate strategy configuration
 * @param {Object} strategy - Strategy object
 * @returns {Array} Array of validation messages
 */
export function validateStrategy(strategy) {
  const messages = []
  
  const { signals, variables, inputs = [] } = strategy

  // Check for duplicate names across variables and inputs
  const allNames = new Map() // name -> array of sources
  ;(variables || []).forEach(v => {
    if (!v.name) return
    if (!allNames.has(v.name)) allNames.set(v.name, [])
    allNames.get(v.name).push('variable')
  })
  ;(inputs || []).forEach(i => {
    if (!i.name) return
    if (!allNames.has(i.name)) allNames.set(i.name, [])
    allNames.get(i.name).push('input')
  })
  allNames.forEach((sources, name) => {
    if (sources.length > 1) {
      messages.push({
        type: 'error',
        message: `Name "${name}" is used multiple times (${sources.join(', ')}), please use different names`
      })
    }
  })

  // Check if at least one signal is enabled with conditions
  const hasEnabledSignal = Object.values(signals || {}).some(
    s => s?.enabled && s.groups?.length > 0 && s.groups.some(g => g.conditions?.length > 0)
  )

  if (!hasEnabledSignal) {
    messages.push({
      type: 'warning',
      message: 'No valid entry/exit conditions configured'
    })
  }

  // Check for entry without exit (strategy.exit with TP/SL counts as an exit)
  const hasLongEntry = signals?.longEntry?.enabled && signals.longEntry.groups?.some(g => g.conditions?.length > 0)
  const hasLongExit = signals?.longExit?.enabled && signals.longExit.groups?.some(g => g.conditions?.length > 0)
  const hasShortEntry = signals?.shortEntry?.enabled && signals.shortEntry.groups?.some(g => g.conditions?.length > 0)
  const hasShortExit = signals?.shortExit?.enabled && signals.shortExit.groups?.some(g => g.conditions?.length > 0)
  const longES = signals?.longEntry?.exitSettings || {}
  const shortES = signals?.shortEntry?.exitSettings || {}
  const hasLongExitSettings = longES.takeProfitEnabled || longES.stopLossEnabled
  const hasShortExitSettings = shortES.takeProfitEnabled || shortES.stopLossEnabled

  if (hasLongEntry && !hasLongExit && !hasLongExitSettings) {
    messages.push({
      type: 'warning',
      message: 'Long entry configured but no long exit condition'
    })
  }

  if (hasShortEntry && !hasShortExit && !hasShortExitSettings) {
    messages.push({
      type: 'warning',
      message: 'Short entry configured but no short exit condition'
    })
  }
  
  // Check variable references in conditions
  const variableIds = new Set((variables || []).map(v => v.id))
  
  Object.values(signals || {}).forEach(signal => {
    if (!signal?.enabled) return
    signal.groups?.forEach(group => {
      group.conditions?.forEach(cond => {
        // Check left operand
        if (cond.left?.type === 'variable' && !variableIds.has(cond.left.variableId)) {
          messages.push({
            type: 'error',
            message: `Condition references a non-existent variable (ID: ${cond.left.variableId})`
          })
        }
        // Check right operand
        if (cond.right?.type === 'variable' && !variableIds.has(cond.right.variableId)) {
          messages.push({
            type: 'error',
            message: `Condition references a non-existent variable (ID: ${cond.right.variableId})`
          })
        }
      })
    })
  })
  
  return messages
}
