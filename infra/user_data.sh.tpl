#!/bin/bash
# Bootstrap script for EC2 instance.
# Installs Docker, clones the project, builds and starts all services,
# ingests SPY data, and sets up SSL.
#
# Variables injected by Terraform templatefile():
#   ${repo_url}           — Git repository URL
#   ${domain_name}        — Domain for the app (and SSL cert)
#   ${admin_email}        — Email for Let's Encrypt
#   ${aws_region}         — AWS region (for Secrets Manager)
#   ${openai_secret_name} — Secrets Manager secret name

set -euo pipefail
exec > /var/log/user-data.log 2>&1
echo "=== Bootstrap started at $(date) ==="

# ── Install Docker + Git LFS ─────────────────────────────────────

yum update -y
yum install -y docker git git-lfs
systemctl enable docker
systemctl start docker
usermod -aG docker ec2-user

# ── Install Docker Compose v2 ───────────────────────────────────

COMPOSE_VERSION="v2.24.0"
mkdir -p /usr/local/lib/docker/cli-plugins
curl -SL "https://github.com/docker/compose/releases/download/$${COMPOSE_VERSION}/docker-compose-linux-x86_64" \
  -o /usr/local/lib/docker/cli-plugins/docker-compose
chmod +x /usr/local/lib/docker/cli-plugins/docker-compose

echo "Docker Compose installed: $(docker compose version)"

# ── Clone project (with LFS data) ────────────────────────────────

cd /opt
git lfs install
git clone ${repo_url} pineback
cd pineback
git lfs pull

echo "Project cloned from ${repo_url}"

# ── Stamp the domain into the nginx config ────────────────────────
# nginx.conf ships with __DOMAIN__ placeholder so the repo stays generic.

sed -i "s/__DOMAIN__/${domain_name}/g" nginx/nginx.conf

# ── Build and start all services ─────────────────────────────────

# Write a .env file so Docker Compose picks up these vars on every
# start/restart — not just the initial `docker compose up`.
cat > .env <<ENVEOF
AWS_DEFAULT_REGION=${aws_region}
OPENAI_SECRET_NAME=${openai_secret_name}
ENVEOF

docker compose -f docker-compose.prod.yml up -d --build

echo "Services started. Waiting for database to be ready..."

# Poll until PgBouncer can accept connections (up to 120s)
for i in $(seq 1 24); do
  if docker compose -f docker-compose.prod.yml exec -T app \
    python -c "import psycopg2, os; psycopg2.connect(os.environ['DATABASE_URL'])" 2>/dev/null; then
    echo "Database is ready (after ~$((i * 5))s)"
    break
  fi
  echo "  Waiting for database... ($((i * 5))s)"
  sleep 5
done

# ── Ingest SPY data ──────────────────────────────────────────────

echo "Ingesting SPY data..."
docker compose -f docker-compose.prod.yml exec -T app python -m server.ingest \
  || echo "WARNING: Data ingestion failed. Run manually: docker compose -f docker-compose.prod.yml exec app python -m server.ingest"

echo "Data ingestion step complete."

# ── SSL Certificate (Let's Encrypt) ──────────────────────────────
# Strategy:
#   1. Install certbot inside the nginx container
#   2. Use --webroot to obtain the cert (no nginx config changes)
#   3. Write a full SSL nginx config ourselves
#   4. Reload nginx
#
# This avoids the read-only bind mount issue with certbot --nginx.

echo "Setting up SSL for ${domain_name}..."

# Step 1+2: Obtain certificate via webroot challenge
docker compose -f docker-compose.prod.yml exec -T nginx sh -c "
  apk add --no-cache certbot 2>/dev/null &&
  certbot certonly --webroot \
    -w /var/lib/letsencrypt \
    -d ${domain_name} \
    --non-interactive \
    --agree-tos \
    -m ${admin_email}
" || { echo "WARNING: SSL cert request failed. DNS may not have propagated yet."; echo "=== Bootstrap complete (without SSL) at $(date) ==="; exit 0; }

# Step 3: Generate the SSL-enabled nginx config on the host,
# then restart the nginx container to pick it up.
cat > /opt/pineback/nginx/nginx.conf <<'SSLCONF'
# nginx reverse proxy for PineBack (SSL-enabled)
# Auto-generated by user_data.sh.tpl during bootstrap.

# Redirect HTTP -> HTTPS
server {
    listen 80;
    server_name DOMAIN_PLACEHOLDER;

    location /.well-known/acme-challenge/ {
        root /var/lib/letsencrypt;
    }

    location / {
        return 301 https://$host$request_uri;
    }
}

# HTTPS server
server {
    listen 443 ssl;
    server_name DOMAIN_PLACEHOLDER;

    ssl_certificate     /etc/letsencrypt/live/DOMAIN_PLACEHOLDER/fullchain.pem;
    ssl_certificate_key /etc/letsencrypt/live/DOMAIN_PLACEHOLDER/privkey.pem;
    ssl_protocols       TLSv1.2 TLSv1.3;
    ssl_ciphers         HIGH:!aNULL:!MD5;

    location / {
        proxy_pass http://app:8000;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;

        # WebSocket support
        proxy_http_version 1.1;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection "upgrade";

        # Timeouts for long-running requests
        proxy_read_timeout 300s;
        proxy_connect_timeout 75s;
    }

    gzip on;
    gzip_types text/plain application/json application/javascript text/css;
    gzip_min_length 1000;
}
SSLCONF

# Replace the domain placeholder
sed -i "s/DOMAIN_PLACEHOLDER/${domain_name}/g" /opt/pineback/nginx/nginx.conf

# Step 4: Restart nginx to load the new config + certs
docker compose -f docker-compose.prod.yml restart nginx

echo "SSL setup complete for ${domain_name}"

echo "=== Bootstrap complete at $(date) ==="
echo "App URL: https://${domain_name}"
